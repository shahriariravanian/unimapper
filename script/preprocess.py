# -*- coding: utf-8 -*-
"""preprocess.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vgKMYzJHKcEyDLsOXGzmKCI1bjaK1-NN
"""

import zfpy
import numpy as np
import json

def compress_cube(path, name, *cubes, precision = 10):
    for cube in cubes:
        c = cube.astype(np.float32)
    return compress_cube(path, name, *c, precision)

def compress_cube(path, name, *cubes, precision=10):
    
    frames, nx, ny = np.shape(cubes[0])
    
    for i, cube in enumerate(cubes):
        channels = compress_channel(cube, path + "_" + str(i) +".zfp", precision)


    D = {
        'version': '1.0',
        'eltype': 'float32',
        'name': name,
        'nx': nx,
        'ny': ny,
        'frames': frames,
        'channels': channels
    }

    json_path = path + ".json"
    fd = open(json_path, "w")
    json.dump(D, fd, indent = 4)
    fd.close()

    return D

def compress_channel(cube, path, precision=10):
    frames, nx, ny = np.shape(cube)
    nz = int(min (pow(2, 21) / (nx * ny), frames))

    v = cube.astype(np.float32)
    segs = segment(frames, nz)

    l = []

    fd = open(path, "wb")

    for s in segs:
        stream = zfpy.compress_numpy(v[s[0]:(s[0] + s[1] - 1),:,:], precision, write_header = False)
        print(stream[0:9])
        l.append(len(stream))
        fd.write(stream)

    fd.close()


    list = []
    for i, s in enumerate(segs):
        d = {"t0": s[0] - 1,
             "t1": s[0] + s[1] - 1,
             "s0": sum(l[0 : i]),
             "s1": sum(l[0 : i + 1])}
        list.append(d.copy())

    μ, σ = find_stretch_function(v)

    return {
        "precision": precision,
        "tol": 0,
        "rate": 0,
        "path": path,
        "segments": list,
        "tanh_loc": μ.astype(float),
        "tanh_scale": σ.astype(float),}

def segment(frames, nz):
    n = []
    m = 1

    while m <= frames:
        l = min(nz, frames + 1 - m)
        n.append((m, l))
        m += l

    return n

def find_stretch_function(v):
    μ = np.mean(v)
    σ = np.std(v)
    return μ, σ

def normalize_data(data):
    frames, nx, ny = np.shape(data)
    cube = np.zeros(np.shape(data), dtype = np.float32)

    for y in range(ny):
        for x in range(nx):
            u = data[:,x,y]
            a = min(u)
            b = max(u)
            cube[:,x,y] = (u - a) / (b - a)
    return cube

def test():
    fd = open("/content/2022-01-23_Exp000_Rec020/2022-01-23_Exp000_Rec020.bin", "rb")
    data_read = np.fromfile(fd, dtype = np.uint16).reshape((1000,128,128))
    data = np.rollaxis(data_read,2,1)
    fd.close()

    # cube also needs to be temporally and spatially filtered
    cube = normalize_data(data)
    path = '/content/2022-01-23_Exp000_Rec020'
    compress_cube(path, "2022-01-23_Exp000_Rec020.bin", cube)

test()

